import pandas as pd
import numpy as np
from scipy.interpolate import interp1d
import logging

class CalibrationManager:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    def load_responsivity_curve(self, filepath: str) -> interp1d:
        """
        Loads a 2-column CSV (Wavelength, Responsivity) and returns an interpolator.
        Assumes no header, or checks if header exists.
        """
        try:
            # Try reading with no header first
            df = pd.read_csv(filepath, header=None)
            
            # Simple heuristic: if first row is strings, it is a header
            if isinstance(df.iloc[0,0], str):
                df = pd.read_csv(filepath) # Reload with header
                cols = df.columns
                x_col, y_col = cols[0], cols[1]
            else:
                x_col, y_col = 0, 1

            # Sort by wavelength
            df = df.sort_values(by=x_col)
            
            x = df[x_col].values
            y = df[y_col].values
            
            # Create interpolator
            interp = interp1d(x, y, kind='linear', fill_value="extrapolate")
            return interp
            
        except Exception as e:
            self.logger.error(f"Failed to load responsivity file: {e}")
            raise

    def generate_led_calibration(self, 
                               measurement_file: str, 
                               reference_responsivity_file: str, 
                               led_wavelength_nm: float) -> pd.DataFrame:
        """
        Generates an LED Power Calibration table (LED_Current -> Optical_Power).
        
        Args:
            measurement_file: CSV containing 'LED_Current_A' and 'Photocurrent_A' (Reference measurement)
            reference_responsivity_file: CSV with reference diode R(lambda)
            led_wavelength_nm: Wavelength to evaluate R_ref at.
            
        Returns:
            DataFrame with ['LED_Current_A', 'Optical_Power_W']
        """
        # 1. Get Reference Responsivity at WL
        r_interp = self.load_responsivity_curve(reference_responsivity_file)
        r_ref = float(r_interp(led_wavelength_nm))
        
        # 2. Load Measurement Data
        df_cal = pd.read_csv(measurement_file)
        
        # Validate columns
        req_cols = ['LED_Current_A', 'Photocurrent_A']
        for c in req_cols:
            if c not in df_cal.columns:
                # Try simple mapping if names differ? For now assume strict or index
                # If generated by our app, it has these names.
                raise ValueError(f"Measurement file missing column: {c}")

        # 3. Calculate Power
        # P_opt = I_pd / R_ref
        df_cal['Optical_Power_W'] = df_cal['Photocurrent_A'].abs() / r_ref
        
        # 4. Result
        result = df_cal[['LED_Current_A', 'Optical_Power_W']].copy()
        result = result.sort_values('LED_Current_A')
        
        return result, r_ref

    def fit_led_power_law(self, df_cal: pd.DataFrame) -> tuple[float, float, float]:
        """
        Fits a Power Law model P = A * I^B to the calibration data.
        Returns: (A, B, R_squared)
        """
        # Filter positive values for log
        valid = (df_cal['LED_Current_A'] > 0) & (df_cal['Optical_Power_W'] > 0)
        df_log = df_cal[valid].copy()
        
        if len(df_log) < 2:
            return 0.0, 1.0, 0.0
            
        x = np.log(df_log['LED_Current_A'].values)
        y = np.log(df_log['Optical_Power_W'].values)
        
        # Fit log(P) = log(A) + B * log(I)
        # y = c + m*x
        m, c = np.polyfit(x, y, 1)
        
        B = m
        A = np.exp(c)
        
        # R2
        yhat = m*x + c
        ybar = np.mean(y)
        ssreg = np.sum((yhat-ybar)**2)
        sstot = np.sum((y-ybar)**2)
        r2 = ssreg/sstot if sstot!=0 else 0
        
        return A, B, r2

    def fit_responsivity_slope(self, df_dut: pd.DataFrame) -> tuple[float, float, float]:
        """
        Fits a linear slope to I_dut vs P_opt to find Responsivity.
        Returns (Slope, Intercept, R_squared)
        """
        if 'Optical_Power_W' not in df_dut.columns or 'Photocurrent_A' not in df_dut.columns:
            return 0.0, 0.0, 0.0
            
        x = df_dut['Optical_Power_W'].values
        y = df_dut['Photocurrent_A'].abs().values # absolute current
        
        # Remove low/zero power points to avoid noise? Or fit all?
        # Fit linear
        coeffs = np.polyfit(x, y, 1)
        slope = coeffs[0]
        intercept = coeffs[1]
        
        # R2
        p = np.poly1d(coeffs)
        yhat = p(x)
        ybar = np.sum(y)/len(y)
        ssreg = np.sum((yhat-ybar)**2)
        sstot = np.sum((y - ybar)**2)
        r2 = ssreg / sstot if sstot != 0 else 0
        
        return slope, intercept, r2
